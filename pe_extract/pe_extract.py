"""
Author: Dominik Reichel (2022-2024)

pe_extract - Extract Windows PE files (EXE, DLL, SYS, unknown) from any given PE, byte blob, memory dump or similar data structure.
"""

__version__ = 0.2

import os
import re
import pefile
import argparse

from dataclasses import dataclass
from enum import IntEnum
from typing import List, Optional
from pefile import PE


@dataclass
class MZItem:
    offset: int
    xor_key: Optional[int] = None


@dataclass
class Report:
    exe: int = 1
    exe_xored: int = 1
    exe_signed: int = 1
    dll: int = 1
    dll_xored: int = 1
    dll_signed: int = 1
    sys: int = 1
    sys_xored: int = 1
    sys_signed: int = 1
    unknown: int = 1
    unknown_xored: int = 1
    unknown_signed: int = 1

    def increase_value(self, field_name: str) -> None:
        curr_val = getattr(self, field_name)
        setattr(self, field_name, curr_val + 1)

    def get_value(self, field_name: str) -> int:
        return getattr(self, field_name)


class InputType(IntEnum):
    File = 1
    Folder = 2
    Unknown = 3


class FileType(IntEnum):
    Exe = 1
    Dll = 2
    Sys = 3
    Unknown = 4


class PEExtract:
    PE_MAGIC = b'\x4D\x5A'
    PE_SIGNATURE = b'\x50\x45\x00\x00'

    def __init__(self, input_path: str, extract_all: bool, skip_xored: bool, extract_overlays: bool, verbose: bool):
        self.input_path = input_path
        self.extract_all = extract_all
        self.skip_xored = skip_xored
        self.extract_overlays = extract_overlays
        self.verbose = verbose
        self.report = Report()

    def __verbose_print(self, message: str):
        if self.verbose:
            print(message)

    def _get_input_type(self) -> InputType:
        result = InputType.Unknown

        if os.path.isfile(self.input_path):
            print('[*] Input path is a file.')
            self.__verbose_print('---')
            result = InputType.File
        elif os.path.isdir(self.input_path):
            print('[*] Input path is a folder.')
            self.__verbose_print('---')
            result = InputType.Folder
        else:
            print('[-] Unknown input. Please provide a valid file/folder path.')

        return result

    def get_file_content(self, file_path: str) -> bytes:
        with open(file_path, 'rb') as f:
            result = f.read()

        if not result:
            self.__verbose_print('\t[-] File is empty.')

        return result

    @staticmethod
    def _is_pe(file_data: bytes) -> bool:
        result = False

        if file_data.startswith(PEExtract.PE_MAGIC):
            pe_signature_index_bytes = file_data[0x3c:0x3c + 4]
            pe_signature_index = int.from_bytes(pe_signature_index_bytes, byteorder='little')
            pe_signature_bytes = file_data[pe_signature_index:pe_signature_index + 4]
            if pe_signature_bytes == PEExtract.PE_SIGNATURE:
                result = True

        return result

    @staticmethod
    def _search_mz_bytes(byte_sequence: bytes, byte_array: bytes) -> List:
        return [x.start() for x in re.finditer(re.escape(byte_sequence), byte_array)]

    def _get_mz_indexes(self, byte_array: bytes) -> List[MZItem]:
        result = []

        if not self.skip_xored:
            for i in range(1, 255):
                mz_bytes_xored = bytes(x ^ i for x in PEExtract.PE_MAGIC)
                mz_offsets_xored = self._search_mz_bytes(mz_bytes_xored, byte_array)

                for mz_offset_xored in mz_offsets_xored:
                    result.append(MZItem(mz_offset_xored, i))

        mz_offsets = self._search_mz_bytes(PEExtract.PE_MAGIC, byte_array)
        for mz_offset in mz_offsets:
            result.append(MZItem(mz_offset))

        if any(x.xor_key for x in result):
            self.__verbose_print('\t[*] XORed magic "MZ" byte(s) found.')

        if any(x.xor_key is None for x in result):
            self.__verbose_print('\t[*] Magic "MZ" byte(s) found.')

        if not result:
            self.__verbose_print('\t[*] No magic "MZ" byte(s) found, file likely does not contain PEs.')

        self.__verbose_print('\t-')

        return result

    def _get_pe_signature_index(self, byte_array: bytes, mz_item: MZItem) -> int:
        pe_signature_index_bytes = byte_array[mz_item.offset + 0x3c:mz_item.offset + 0x3c + 4]

        if mz_item.xor_key:
            pe_signature_index_bytes = bytes(x ^ mz_item.xor_key for x in pe_signature_index_bytes)

        result = int.from_bytes(pe_signature_index_bytes, byteorder='little')

        if not result:
            self.__verbose_print('\t[*] End of file reached.')

        return result

    def _check_pe_signature(self, signature: bytes, xor_key: int) -> bool:
        result = False

        if xor_key and signature == bytes(x ^ xor_key for x in PEExtract.PE_SIGNATURE):
            self.__verbose_print('\t[*] XORed "PE" signature found.')
            result = True
        elif signature == PEExtract.PE_SIGNATURE:
            self.__verbose_print('\t[*] "PE" signature found.')
            result = True

        return result

    def get_file_type(self, pe: PE) -> FileType:
        result = FileType.Unknown

        if pe.is_exe():
            self.__verbose_print('\t[+] Found EXE file.')
            result = FileType.Exe
        elif pe.is_dll():
            self.__verbose_print('\t[+] Found DLL file.')
            result = FileType.Dll
        elif pe.is_driver():
            self.__verbose_print('\t[+] Found SYS file.')
            result = FileType.Sys
        else:
            self.__verbose_print('\t[+] Found unknown file.')

        return result

    def get_file_bitness(self, pe: PE) -> str:
        result = ''

        if (pe.OPTIONAL_HEADER.Magic & pefile.OPTIONAL_HEADER_MAGIC_PE) == pefile.OPTIONAL_HEADER_MAGIC_PE:
            self.__verbose_print('\t[*] File is for 32-bit architecture.')
            result = '32'
        elif (pe.OPTIONAL_HEADER.Magic & pefile.OPTIONAL_HEADER_MAGIC_PE_PLUS) == pefile.OPTIONAL_HEADER_MAGIC_PE_PLUS:
            self.__verbose_print('\t[*] File is for 64-bit architecture.')
            result = '64'

        return result

    def is_page_sized_pe(self, file_size: int) -> bool:
        result = True

        if file_size == 4096:
            self.__verbose_print('\t[*] Extracted PE file has memory page size of 4,096 bytes and is likely incomplete.')
            result = False

        return result

    def is_signed_pe(self, pe_file: PE) -> bool:
        result = False

        if pe_file.OPTIONAL_HEADER.DATA_DIRECTORY[
            pefile.DIRECTORY_ENTRY["IMAGE_DIRECTORY_ENTRY_SECURITY"]].VirtualAddress and \
                pe_file.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY["IMAGE_DIRECTORY_ENTRY_SECURITY"]].Size:
            self.__verbose_print('\t[*] File is signed.')
            result = True

        return result

    @staticmethod
    def get_pe_with_signature(pe_file: PE) -> bytes:
        signature_size = pe_file.OPTIONAL_HEADER.DATA_DIRECTORY[
            pefile.DIRECTORY_ENTRY["IMAGE_DIRECTORY_ENTRY_SECURITY"]].Size
        overlay_data_offset = pe_file.get_overlay_data_start_offset()

        return pe_file.__data__[:overlay_data_offset + signature_size]

    def __summary_report(self) -> None:
        print('---')
        print('Found and extracted:')
        print(f'\tEXE files - {self.report.exe - 1} '
              f'({self.report.exe_xored - 1} XORed; {self.report.exe_signed - 1} signed)')
        print(f'\tDLL files - {self.report.dll - 1} '
              f'({self.report.dll_xored - 1} XORed; {self.report.dll_signed - 1} signed)')
        print(f'\tSYS files - {self.report.sys - 1} '
              f'({self.report.sys_xored - 1} XORed; {self.report.sys_signed - 1} signed)')
        print(f'\tUnknown files - {self.report.unknown - 1} '
              f'({self.report.unknown_xored - 1} XORed; {self.report.unknown_signed - 1} signed)')

    def extract_from_file(self, file_path: str) -> None:
        file_content = self.get_file_content(file_path)
        if not file_content:
            return

        # Check if input file is a PE itself to prevent self-extraction
        if self._is_pe(file_content):
            file_content = file_content[1:]

        self.__verbose_print(f'Extracting files from: {file_path}')
        # Search for magic 'MZ' bytes
        mz_items = self._get_mz_indexes(file_content)

        for mz_item in mz_items:
            self.__verbose_print(f'\t[+] Processing \'MZ\' magic bytes indicator at {hex(mz_item.offset)}')
            # Get index of 'PE' signature
            pe_signature_index = self._get_pe_signature_index(file_content, mz_item)

            # Check if 'PE' signature exists at index and if true extract PE file
            if self._check_pe_signature(
                    file_content[mz_item.offset + pe_signature_index:mz_item.offset + pe_signature_index + 4],
                    mz_item.xor_key):
                # Decrypt file bytes when XORed PE was found
                if mz_item.xor_key:
                    pe_bytes = bytes(x ^ mz_item.xor_key for x in file_content[mz_item.offset:])
                else:
                    pe_bytes = file_content[mz_item.offset:]

                # Create pefile instance from file bytes
                pe_file = pefile.PE(data=pe_bytes)

                # Check if file has memory page size when --extract-all argument wasn't chosen
                if not self.extract_all and not self.is_page_sized_pe(len(pe_file.__data__)):
                    continue

                # Create folder for extracted PE files
                if not os.path.exists(f'{file_path}_files'):
                    os.mkdir(f'{file_path}_files')

                # Get PE file type and if it was XORed
                pe_file_type = self.get_file_type(pe_file).name.lower()
                pe_file_type = f'{pe_file_type}_xored' if mz_item.xor_key else pe_file_type

                # Get PE file bitness
                pe_file_bitness = self.get_file_bitness(pe_file)
                bitness_string = f'_x{pe_file_bitness}' if pe_file_bitness else ''

                # Create file write path for extracted PE
                pe_file_path = os.path.join(f'{file_path}_files',
                                            f'{pe_file_type}{bitness_string}_{self.report.get_value(pe_file_type)}.bin')

                # Increase file type pointer for file name and report
                self.report.increase_value(pe_file_type)

                # Increase also normal file type counter if XORed PE was found
                if mz_item.xor_key:
                    self.report.increase_value(pe_file_type + '_xored')

                # Write extracted PE file to disk
                if self.extract_overlays:
                    pe_file.write(pe_file_path)
                    pe_file.close()
                else:
                    if self.is_signed_pe(pe_file):
                        self.report.increase_value(pe_file_type + '_signed')
                        pe_file_bytes = self.get_pe_with_signature(pe_file)
                    else:
                        pe_file_bytes = pe_file.trim()
                    with open(pe_file_path, 'wb') as f:
                        f.write(pe_file_bytes)

                self.__verbose_print(f'\t[+] Extracted PE written to: {pe_file_path}')
            self.__verbose_print('\t-')

    def extract_from_folder(self) -> None:
        for root, _, files in os.walk(self.input_path):
            print(f'[*] Found {len(files)} files in "{self.input_path}".')
            for file in files:
                self.extract_from_file(os.path.join(root, file))
            break

    def extract(self) -> None:
        print(f'Input: "{self.input_path}"')
        input_type = self._get_input_type()

        if input_type == InputType.File:
            self.extract_from_file(self.input_path)
        elif input_type == InputType.Folder:
            self.extract_from_folder()

        self.__summary_report()


def main():
    parser = argparse.ArgumentParser(description='Extract EXE, DLL, SYS and unknown PE(s) from byte blob(s).')
    parser.add_argument('input', type=str, help='Input file/folder (absolute path).')
    parser.add_argument('-s', '--skip-xor-extraction', dest='skip_xored', action='store_true',
                        help='Skip extraction of simple XORed PE files.')
    parser.add_argument('-o', '--extract-pe-overlays', dest='extract_overlays', action='store_true',
                        help='Extract also possible PE overlay data (unreliable).')
    parser.add_argument('-a', '--extract-all', dest='extract_all', action='store_true',
                        help='Extract also (likely) incomplete PEs from memory page size dumps.')
    parser.add_argument('-v', '--verbose-output', dest='verbose', action='store_true',
                        help='Show detailed output.')
    args = parser.parse_args()

    pe_extract = PEExtract(args.input, args.extract_all, args.skip_xored, args.extract_overlays, args.verbose)
    pe_extract.extract()


if __name__ == "__main__":
    main()
