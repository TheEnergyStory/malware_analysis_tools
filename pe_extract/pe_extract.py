"""
Author: Dominik Reichel (2022)

pe_extract - Extract EXE, DLL, SYS and unknown files from any given byte blob, memory dump or similar data structure.
"""

__version__ = 0.1

import os
import re
import pefile
import argparse

from dataclasses import dataclass
from enum import IntEnum
from typing import List, Optional
from pefile import PE


@dataclass
class MZItem:
    offset: int
    xor_key: Optional[int] = None


class InputType(IntEnum):
    File = 1
    Folder = 2
    Unknown = 3


class FileType(IntEnum):
    Exe = 1
    Dll = 2
    Sys = 3
    Unknown = 4


class PEExtract:
    def __init__(self, input_path: str, extract_all: bool, extract_xored: bool, extract_overlays: bool):
        self.input_path = input_path
        self.extract_all = extract_all
        self.extract_xored = extract_xored
        self.extract_overlays = extract_overlays
        self.file_counter = {
            'exe': 1,
            'exe_xored': 1,
            'dll': 1,
            'dll_xored': 1,
            'sys': 1,
            'sys_xored': 1,
            'unknown': 1,
            'unknown_xored': 1
        }

    def _get_input_type(self) -> InputType:
        result = InputType.Unknown

        if os.path.isfile(self.input_path):
            print('[*] Input path is a file.\n---')
            result = InputType.File
        elif os.path.isdir(self.input_path):
            print('[*] Input path is a folder.\n---')
            result = InputType.Folder
        else:
            print('[-] Unknown input. Please provide a valid file/folder path.')

        return result

    @staticmethod
    def get_file_content(file_path: str) -> bytes:
        with open(file_path, 'rb') as f:
            result = f.read()

        if not result:
            print('\t[-] File is empty.')

        return result

    @staticmethod
    def _search_mz_bytes(byte_sequence: bytes, byte_array: bytes) -> List:
        return [x.start() for x in re.finditer(re.escape(byte_sequence), byte_array)]

    def _get_mz_indexes(self, byte_array: bytes) -> List[MZItem]:
        mz_bytes = b'\x4D\x5A'
        result = []

        if self.extract_xored:
            for i in range(1, 255):
                mz_bytes_xored = bytes(x ^ i for x in mz_bytes)
                mz_offsets_xored = self._search_mz_bytes(mz_bytes_xored, byte_array)

                for mz_offset_xored in mz_offsets_xored:
                    result.append(MZItem(mz_offset_xored, i))

        mz_offsets = self._search_mz_bytes(mz_bytes, byte_array)
        for mz_offset in mz_offsets:
            result.append(MZItem(mz_offset))

        if any(x.xor_key for x in result):
            print('\t[*] XORed magic "MZ" byte(s) found.')

        if any(x.xor_key is None for x in result):
            print('\t[*] Magic "MZ" byte(s) found.')

        if not result:
            print('\t[*] No magic "MZ" byte(s) found, file likely does not contain PEs.')

        return result

    @staticmethod
    def _get_pe_signature_index(byte_array: bytes, mz_item: MZItem) -> int:
        pe_signature_index_bytes = byte_array[mz_item.offset + 0x3c:mz_item.offset + 0x3c + 4]

        if mz_item.xor_key:
            pe_signature_index_bytes = bytes(x ^ mz_item.xor_key for x in pe_signature_index_bytes)

        result = int.from_bytes(pe_signature_index_bytes, byteorder='little')

        if not result:
            print('\t[*] End of file reached.')

        return result

    @staticmethod
    def _check_pe_signature(signature: bytes, xor_key: int) -> bool:
        pe_signature = b'\x50\x45\x00\x00'
        result = False

        if xor_key and signature == bytes(x ^ xor_key for x in pe_signature):
            print('\t[*] XORed "PE" signature found.')
            result = True
        elif signature == pe_signature:
            print('\t[*] "PE" signature found.')
            result = True
        else:
            print('\t[*] No valid "PE" signature found.')

        return result

    @staticmethod
    def get_file_type(pe: PE) -> FileType:
        result = FileType.Unknown

        if pe.is_exe():
            print('\t[+] Found EXE file.')
            result = FileType.Exe
        elif pe.is_dll():
            print('\t[+] Found DLL file.')
            result = FileType.Dll
        elif pe.is_driver():
            print('\t[+] Found SYS file.')
            result = FileType.Sys
        else:
            print('\t[+] Found unknown file.')

        return result

    @staticmethod
    def get_file_bitness(pe: PE) -> str:
        result = ''

        if (pe.OPTIONAL_HEADER.Magic & pefile.OPTIONAL_HEADER_MAGIC_PE) == pefile.OPTIONAL_HEADER_MAGIC_PE:
            print('\t[*] File is for 32-bit architecture.')
            result = '32'
        elif (pe.OPTIONAL_HEADER.Magic & pefile.OPTIONAL_HEADER_MAGIC_PE_PLUS) == pefile.OPTIONAL_HEADER_MAGIC_PE_PLUS:
            print('\t[*] File is for 64-bit architecture.')
            result = '64'

        return result

    @staticmethod
    def is_pe_complete(file_bytes: bytes) -> bool:
        result = True

        if len(file_bytes) == 4096:
            print('\t[*] Extracted PE file has memory page size of 4,096 bytes and is likely incomplete.')
            result = False

        return result

    def __summary_report(self) -> None:
        print('---\n---')
        print('Found and extracted:')
        print(f'\tEXE files - {self.file_counter["exe"] - 1} ({self.file_counter["exe_xored"] - 1} XORed)')
        print(f'\tDLL files - {self.file_counter["dll"] - 1} ({self.file_counter["dll_xored"] - 1} XORed)')
        print(f'\tSYS files - {self.file_counter["sys"] - 1} ({self.file_counter["sys_xored"] - 1} XORed)')
        print(f'\tUnknown files - {self.file_counter["unknown"] - 1}  ({self.file_counter["unknown_xored"] - 1} XORed)')

    def extract_from_file(self, file_path: str) -> None:
        file_content = self.get_file_content(file_path)

        if file_content:
            print(f'Process file: {file_path}')

            # Search for magic 'MZ' bytes
            mz_items = self._get_mz_indexes(file_content)

            for mz_item in mz_items:
                # Get index of 'PE' signature
                pe_signature_index = self._get_pe_signature_index(file_content, mz_item)

                # Check if 'PE' signature exists at index and if true extract PE file
                if self._check_pe_signature(
                        file_content[mz_item.offset + pe_signature_index:mz_item.offset + pe_signature_index + 4],
                        mz_item.xor_key):
                    # Check if file is complete when --extract-all argument was chosen
                    if self.extract_all or self.is_pe_complete(file_content[mz_item.offset:]):
                        # Decrypt file bytes when XORed PE was found
                        if mz_item.xor_key:
                            pe_bytes = bytes(x ^ mz_item.xor_key for x in file_content[mz_item.offset:])
                        else:
                            pe_bytes = file_content[mz_item.offset:]

                        # Create pefile instance from file bytes
                        pe_file = pefile.PE(data=pe_bytes)

                        # Create folder for extracted PE files
                        if not os.path.exists(f'{file_path}_files'):
                            os.mkdir(f'{file_path}_files')

                        # Get PE file type and if it was XORed
                        pe_file_type = self.get_file_type(pe_file).name.lower()
                        pe_file_type = f'{pe_file_type}_xored' if mz_item.xor_key else pe_file_type
                        # Get PE file bitness
                        pe_file_bitness = self.get_file_bitness(pe_file)
                        bitness_string = f'_x{pe_file_bitness}' if pe_file_bitness else ''

                        # Create file write path for extracted PE
                        pe_file_path = os.path.join(f'{file_path}_files',
                                                    f'{pe_file_type}{bitness_string}_{self.file_counter[pe_file_type]}.bin')

                        # Increase also normal file type counter if XORed PE was found
                        if mz_item.xor_key:
                            self.file_counter[pe_file_type.replace('_xored', '')] += 1

                        # Increase file type pointer for file name and report
                        self.file_counter[pe_file_type] += 1

                        # Write extracted PE file to disk
                        if not self.extract_overlays:
                            pe_trimmed = pe_file.trim()
                            with open(pe_file_path, 'wb') as f:
                                f.write(pe_trimmed)
                        else:
                            pe_file.write(pe_file_path)
                            pe_file.close()

                        print(f'\t[+] Extracted PE written to: {pe_file_path}')

    def extract_from_folder(self) -> None:
        for root, _, files in os.walk(self.input_path):
            print(f'[*] Found {len(files)} files in folder.')
            for file in files:
                self.extract_from_file(os.path.join(root, file))

    def extract(self) -> None:
        print(f'Input: "{self.input_path}"')
        input_type = self._get_input_type()

        if input_type == InputType.File:
            self.extract_from_file(self.input_path)
        elif input_type == InputType.Folder:
            self.extract_from_folder()

        self.__summary_report()


def main():
    parser = argparse.ArgumentParser(description="Extract EXE, DLL, SYS and unknown PE(s) from byte blob(s).")
    parser.add_argument("input", type=str, help="Input file/folder (absolute path).")
    parser.add_argument('--extract-pe-overlays', dest='extract_overlays', action='store_true',
                        help='Extract also possible PE overlay data (unreliable).')
    parser.add_argument('--extract-xored', dest='extract_xored', action='store_true',
                        help='Extract also XORed PE files.')
    parser.add_argument('--extract-all', dest='extract_all', action='store_true',
                        help="Extract also (likely) incomplete PEs from memory page size dumps.")
    args = parser.parse_args()

    pe_extract = PEExtract(args.input, args.extract_all, args.extract_xored, args.extract_overlays)
    pe_extract.extract()


if __name__ == "__main__":
    main()
